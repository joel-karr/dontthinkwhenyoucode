# Find Your Origin Story {#sec-find-your-origin-story}

Filename: The_Origin.md

<!-- begin chapter id="chp.origin_story" -->

<!-- begin storymap -->
Why do I want to read this?

: You want to understand why you became obsessed with programming in the first place and why some people become lifelong engineers while others quit after a few frustrated attempts.

What will I learn?

: You will learn about the science behind getting into a state of flow and how it is in itself what drives further motivation, not compensation or other material rewards.

What will I be able to do that I couldn't do before?

: You will be able to identify the conditions that lead to flow and how to create an environment that enables it, allowing you to advance your skills more effectively. You also will start to understand that you need to be comfortable being uncomfortable in order to continue to push yourself.

Where are we going next, and how does this fit in?

: In the next chapter, we will discuss how to train your subconscious. This chapter helps you understand how trusting the process can keep you motivated.
<!-- end storymap -->

<!-- begin sect1 -->

There's a book that's sat on my shelf for over 30 years. It holds the magical powers to instantly transport me back to the first time I felt deep flow while coding. I can still feel the cool basement air and see the glow of the computer screen all those years ago. It was in that basement that time first melted away and I felt all my outside worries and pressures disappear.

Most origin stories in software engineering don't start with passion for coding. After all, how can you have passion for something that you don't even comprehend at first? They start with curiosity or a desire to build something to solve a specific problem.

This chapter is about that beginning. More importantly, it's about what drives you past frustration repeatedly. You'll see how flow works, why it matters for your growth as an engineer, and how you can deliberately create the conditions that keep you coming back to it.

Let me take you back to where it started for me.

In my small town, I was the kid always hunting for the next challenge. I competed in everything: reading the most books, selling the most candy bars for fundraisers, always looking for problems that needed solving.

I still remember walking to the snow-cone hut in the parking lot of our local grocery store, studying how they operated. I was convinced I could build a better business—with miniature horses pulling my cart. Because while a parent might say no to a snow cone, how could they possibly tell their kid they couldn't pet the horse? I had the whole business plan mapped out in my head, complete with the logistics of horse care and cart design. That's the kind of mind I had: always reverse-engineering what I saw and imagining how to make it better.

It was 1995, so the internet hadn't yet opened up everyone to endless possibilities. My dad recognized this restless energy and knew I'd exhausted most of what was being taught in school. My dad found something at Illinois State University's bookstore that might be exactly the kind of challenge I needed—a book called *QuickBASIC Made Easy* by Bob Albrecht, Wenden Wiegand, and Dean Brown. This was the book that would change everything—the same one with the magical power to transport me back to that cold basement.

The book taught QuickBASIC in a very step-by-step way. At first, I found it frustrating because I wanted to build something that I cared about, not what the book told me to build. Without any knowledge, I couldn't problem solve, and without the ability to problem solve, I felt trapped.

*This is where most people quit.*

Our brains are wired to avoid cognitive taxation. When we encounter something that requires significant mental effort without immediate reward, every instinct tells us to stop. Find something easier. Stick to what we already know how to do.

Despite that initial feeling to avoid the challenge, curiosity drove me to follow the step-by-step instructions. The first lessons were printing out things like the current date, and quickly I became familiar with the concept of syntax errors. Code was unforgiving, and at the time there were no tools to highlight what was wrong.

Many years later, someone told me that all software engineers are optimists, and at first that sounded crazy. But even this early experience proved their point: *if you aren't an optimist, you give up long before you can make it a career path.*

I spent the next few weeks determined to read the 355-page book. As I made my way along, I learned how to control colors, make music notes, and lots and lots of math functions, but none of it was something that solved any real-life problems I experienced. I felt like I was collecting knowledge, but did not have a good enough understanding to be able to apply it to something outside of the book.

I tried showing my friends some of the sample projects that I had built, but no one was impressed by a computer playing strange-sounding music notes. I built text-based games like some of the examples in the book, but to everyone else it was still just lines of text.

I decided I needed to build something visual.

I already knew how to draw lines and fill in the resulting shapes from the book, so I got some graph paper and traced out a word in big block letters. I mapped out each point, counting how many squares across and up from the bottom corner. I spent the next few days drawing out words from complex graph paper patterns. I was finally building something that I could show off...but it felt inefficient. There had to be a better way.

Then it happened.

I was on my eighth sheet of graph paper when I came up with a big idea. What if I used variable offsets for each letter inside a 10 by 10 grid? Then I could change the bottom left corner of the start of the letter and quickly place letters anywhere on the page.

I wrote out a full plan: I would first draw each letter and number onto graph paper, then I would create a method for each letter to draw on the page taking in an <variable>x</variable> and <variable>y</variable> value. I started creating the full alphabet and numbers 0-9.

Time seemed to disappear as I worked.

What felt like thirty minutes really was four or five hours. Not only had I created a solution that would allow me to create large words that looked much better than simple console line text, but I felt amazing.

What I didn't understand at the time was that this moment was about more than just learning to code. I had accidentally stumbled into one of the most well-researched psychological states: flow.
<!-- end sect1 -->

<!-- begin sect1 -->

## The Neuroscience of Why We Continue {#sec-the-neuroscience-of-why-we-continue}

<!-- AI:BEGIN:figure-placeholder -->
<!-- Figure placeholder: consider adding an illustration of the flow state components (challenge vs skill, feedback loop) -->
<!-- AI:END:figure-placeholder -->

When most people try programming for the first time, they quit within hours. The syntax feels foreign. The error messages are cryptic. The feedback loop between effort and visible progress feels broken.

But for a small percentage of people, the ones who become software engineers, something different happens.

Maybe for you it was the moment your first "Hello World" program finally runs. Maybe it was solving your first logic puzzle. Maybe it was the satisfaction of finding and fixing your first bug.

Whatever the trigger, you got a tiny taste of flow state. And once your brain experiences that, even briefly, it starts seeking more.

This is where the real addiction begins. Not to programming itself, but to the flow state that programming uniquely enables.

Unlike most activities that provide instant gratification, programming requires you to build a tolerance for confusion. You have to have patience with not knowing. You have to iterate through failure. You have to trust that understanding will eventually emerge if you keep working at it.

This tolerance for confusion is what separates people who become great engineers from people who try programming and walk away.

That QuickBASIC book taught me something that no amount of Stack Overflow answers could: *mastery begins with accepting that confusion is temporary, and pushing through it.*

Whether you are struggling to build an application for the first time or have already built elegant solutions, we're all on the same journey. The only way to keep reaching a flow state is to keep challenging ourselves.
<!-- end sect1 -->

<!-- begin sect1 -->

## When the Same Work Feels Different {#sec-when-the-same-work-feels-different}

Sometimes, even when the code that software engineers are writing looks the same, they can't get into a state of flow. Many software engineers have taken on a small side project for extra cash. Maybe it's enough for a hot tub, or a vacation they've been planning. They've got the skills, the requirements seem clear, and they are confident it will be straightforward. 

But without real emotional investment, the work quickly feels burdensome. The same types of code challenges that once felt exciting turns into an exercise in logging hours.

A similar mystery caught the attention of a young psychology researcher at the University of Chicago in the 1970s. He was watching painters work at their easels, and he noticed something that seemed counter-intuitive according to the psychological theories of the time.

Mihaly Csikszentmihalyi expected to confirm the prevailing theories at the time about motivation and reward. What he saw instead challenged everything most psychologists thought they knew about what motivated people to work.

As Csikszentmihalyi watched the artists painting, he was intrigued by the almost trancelike state they entered when the work was going well. According to the most studies on behavioral psychology, their primary motivation should have been the reward of a finished painting—the external validation, the potential sale, the completed achievement.

But the painters behaved in unexpected ways. They became so focused in their work that they ignored basic survival instincts. They worked for hours, oblivious to their surroundings. They lost track of time entirely.

Software engineers know this phenomenon intimately. They start debugging a particularly tricky issue before lunch, and the next thing they know it's late afternoon. They are suddenly starving and desperately need a bathroom break, but they've been so absorbed in the problem that their body's signals didn't register. The challenge itself became more compelling than basic physical needs.

Even more surprising, Csikszentmihalyi noticed the moment the artists finished a painting, they lost all interest in it. They'd set it aside and immediately want to start something new.

If creating art was about producing beautiful objects for external rewards, why didn't they care about the finished product? Why did the process seem more compelling than the outcome?

This observation sparked a question that would drive decades of research: What is this state of complete engagement, and why does it seem more rewarding than the external benefits people supposedly work for?
<!-- end sect1 -->

<!-- begin sect1 -->

## The Discovery of Flow {#sec.discovery_of_flow}

Csikszentmihalyi began systematic research into what he called autotelic experiences, activities you want to do for their own sake, as opposed to exotelic activities done for external rewards.

In his 1975 book, *Beyond Boredom and Anxiety: Experiencing Flow in Work and Play*, Csikszentmihalyi and his team studied four activities: chess, rock climbing, rock dancing (freeform dancing to rock music), and surgery. Except for surgery, all of these were activities people considered for leisure rather than a job. He hoped that by studying things people choose to do for enjoyment, he could learn how work could be made more enjoyable.

What he uncovered was a universal state of deep engagement, one that appeared across wildly different activities. The next step was to understand what this state looked like in detail.

To study this further, he developed the Experience Sampling Method, which asked participants eight times a day to record what they were doing and how they felt. 

His research revealed a surprising paradox. Subjects were most likely to be in flow at work, yet they preferred leisure activities. People were experiencing their optimal states during challenging work, but they didn't recognize it.

The characteristics of flow were remarkably consistent across activities:

- *Complete concentration*---fully focused, no outside distractions
- *Clear goals*---measurable and distinct
- *Balance between challenge and skill*---difficult enough to require focus, not so hard as to create anxiety
- *Merging of action and awareness*---self-consciousness disappears
- *Distorted sense of time*---hours feel like minutes
- *Intrinsic motivation*---the activity becomes rewarding in itself

His research showed that the conditions for deep engagement are universal, and understanding them is the first step to learning how to create flow in our own work.
<!-- end sect1 -->

<!-- begin sect1 -->

## Why This Matters More Than Your Salary {#sec-why-this-matters-more-than-your-salary}

Csikszentmihalyi's findings have huge implications for engineers. Flow isn’t just an academic concept. It explains why the same coding work sometimes feels effortless and energizing, and other times feels like a grind. When you're building something just for the money, even lots of money, you're engaged in exotelic activity. The reward is external to the work itself. But when you're focused on a challenging technical problem that matches your skill level, providing clear goals and immediate feedback, you enter a flow state.

The flow state itself becomes the reward, and it's more compelling than any external benefit. Of course salary and other benefits matter, but they aren't enough to keep you motivated through the hardest parts of software engineering.

As Csikszentmihalyi explained in his 1990 book, *Flow: The Psychology of Optimal Experience*: "Contrary to what we usually believe, moments like these, the best moments in our lives, are not the passive, receptive, relaxing times—although such experiences can also be enjoyable, if we have worked hard to attain them. The best moments usually occur when a person's body or mind is stretched to its limits in a voluntary effort to accomplish something difficult and worthwhile."

This insight reveals something crucial about building a sustainable engineering career. The activities that provide our highest quality experience are often challenging technical work like debugging complex systems, solving architectural puzzles, learning new paradigms. These aren't interruptions to our "real" work. They are the experiences that make work intrinsically rewarding.

If we focus on outcomes like promotions or product launches, we lose sight of the real driver of happiness: the journey itself. The journey allows us to return to a state of flow again and again.

Csikszentmihalyi's research also showed something profound about human motivation: training our brains to think systematically is a cognitive load that material rewards simply cannot sustain. Money, status, promotions, these external motivators aren't powerful enough to push us through the discomfort of genuine learning and growth.

But the state of flow? Flow is strong enough to make us ignore our most basic human survival instincts. It's powerful enough to make us forget to eat, lose track of time, and willingly embrace challenges that push us to our limits.

Understanding the neuroscience helps, but it doesn't solve the fundamental challenge: How do you systematically build the competence that makes flow accessible?

The answer isn't more production work. Working harder doesn't automatically create the conditions for flow. In fact, most professional software development environments actively prevent flow through constant interruptions, unclear requirements, and unrealistic deadlines.

*The answer is deliberate practice.* If you're wondering what this means, I'll tell you all about it in [xxx](#chp.deliberate_practice).

Becoming a successful software engineer is far more than memorizing syntax and design patterns. Great engineers build habits that fuel constant growth and take on harder projects that push them into flow.

<!-- end sect1 -->

<!-- begin sect1 -->

## Finding Your Motivation {#sec-finding-your-motivation}

<!-- AI:BEGIN:mini-toc -->

## In this chapter
- See @sec-the-neuroscience-of-why-we-continue
- See @sec-when-the-same-work-feels-different
- See @sec-discovery_of_flow

<!-- AI:END:mini-toc -->

The following steps are designed to help you connect the concepts in this chapter to your own career. They’ll also give you a foundation we’ll build on in later chapters. Each chapter ends with steps that will help you apply the ideas you learn about right away.

<!-- begin sect2 -->

### Step 1: Recognize Your Material Motivators

Before you can harness the power of intrinsic motivation, you need to understand how you've been thinking about external rewards. Take a few minutes to write down your honest answers to these questions:

- What material reasons have driven you to write code in the past? (Money, career advancement, recognition, etc.)
- What external rewards are you currently working toward in your engineering career?
- When you think about learning a new technology or skill, what external benefits usually motivate you?
* What material reasons have driven you to write code in the past? (Money, career advancement, recognition, etc.)
* What external rewards are you currently working toward in your engineering career?
* When you think about learning a new technology or skill, what external benefits usually motivate you?

There's nothing wrong with these motivators. They're necessary for survival and career progression. But recognizing them helps you see when you’re focused on external rewards versus internal drivers.
<!-- end sect2 -->

<!-- begin sect2 -->

### Step 2: Reflect on Your Flow Experiences

Now think about the times when you've experienced flow while coding or solving technical problems:

- Describe a recent time when you lost track of time while working on a challenging technical problem. What made that experience compelling?
- How did it feel when you finally solved that problem? Compare that feeling to receiving a raise or bonus.
- What is it about the process of getting better at engineering that you genuinely love, beyond any external rewards?
* Describe a recent time when you lost track of time while working on a challenging technical problem. What made that experience compelling?
* How did it feel when you finally solved that problem? Compare that feeling to receiving a raise or bonus.
* What is it about the process of getting better at engineering that you genuinely love, beyond any external rewards?

Write down your answers along with your answers from Step 1. You'll need both sets of reflections for the next step. You are starting to identify the contrast between the pull of external motivators and the power of being in a state of flow. This contrast helps you to understand what sustains your career in the long run.

<!-- end sect2 -->

<!-- begin sect2 -->

### Step 3: Write Your Own Origin Story

Now it's time to put it all together. Think back to your own origin story with software engineering.

* What was the moment you first felt that pull to continue despite the difficulty? 
* What did that early experience feel like, and how did it differ from other challenging activities you'd tried?
* Looking at your answers from Steps 1 and 2, which parts of your story were driven by material motivators and which came from the pleasure of being in a state of flow?

Write at least a few paragraphs. Your origin story will remind you of why you started, help you notice when you're chasing rewards that don't actually motive you, and guide you back to the intrinsic drive that overcomes challenges. You can add your origin story to a notebook you will start in the next chapter.

<!-- end sect2 -->
<!-- end sect1 -->

<!-- AI:BEGIN:end-matter -->
## Exercises
- Write your origin story and share one paragraph with a peer or in your notebook.
- Identify one activity this week to deliberately pursue that pushes you just beyond your comfort zone.

<!-- AI:END:end-matter -->
<!-- begin sect1 -->

## Up Next: Deliberate Practice

Flow shows us what’s possible when skill and a challenge align, but we don't have to leave it to chance. To return to this state reliably, we can use the same type of structured training athletes use: repetition, feedback, and focused intent. In the next chapter, we’ll explore practice methods that turn flow from a lucky accident into something you can deliberately create. We'll learn how to turn challenges into opportunities for mastery, and how to make the journey itself the most rewarding part of being a software engineer.
<!-- end sect1 -->
<!-- end chapter -->
